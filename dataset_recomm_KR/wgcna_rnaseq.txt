{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "title: Running the WGCNA algorithm on an example RNASEQ dataset\n",
    "tldr: Demonstrating the WGCNA algorithm on an exmaple RNASeq WGCNA dataset. Downloads the data from DEE2.io, annotates it and runs WGCNA.\n",
    "---"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Download GSE114597 data from S3"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "library(aws.s3)\n",
    "aws.signature::use_credentials()\n",
    "save_object(object = \"DEE2_RNASeq/GSE114597.csv\", bucket = \"wgcna-geo-datasets\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "GSE_matrix <- read.csv(\"GSE114597.csv\", stringsAsFactors = F)\n",
    "if (\"X\" %in% colnames(GSE_matrix)) {\n",
    "      rownames(GSE_matrix) <- GSE_matrix$X\n",
    "      GSE_matrix <- GSE_matrix[, colnames(GSE_matrix) != \"X\"]\n",
    "}\n",
    "head(GSE_matrix)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "dim(GSE_matrix)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Annotate with entrez ids"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Get annotation file"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "library(googledrive)\n",
    "drive_auth(service_token = 'knowledgerepo-189317-3c6116e9ad56.json')\n",
    "td <- team_drive_get(\"DataScience\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "file <- drive_get(\"RecommendationEngine/WGCNA_AML/ensembl-to-entrez.tsv\", team_drive = td)\n",
    "drive_download(file, overwrite = T)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "GSE_matrix <- GSE_matrix[!is.na(rownames(GSE_matrix)), ]\n",
    "GSE_matrix <- GSE_matrix[rownames(GSE_matrix) != \"\", ]\n",
    "\n",
    "ensembl_to_entrez_df <- read.table(\"ensembl-to-entrez.tsv\",\n",
    "sep = \"\\t\", stringsAsFactors = F\n",
    ")\n",
    "\n",
    "m <- match(rownames(GSE_matrix), ensembl_to_entrez_df[, 3])\n",
    "\n",
    "GSE_matrix_df <- data.frame(GSE_matrix, stringsAsFactors = F)\n",
    "GSE_matrix_df$entrez_id <- ensembl_to_entrez_df[m, 2]\n",
    "GSE_matrix_df <- GSE_matrix_df[!is.na(GSE_matrix_df$entrez_id), ]\n",
    "GSE_matrix_df$mad_score <- apply(\n",
    "GSE_matrix_df[, !grepl(\"entrez_id\", colnames(GSE_matrix_df))],\n",
    "1, function(x) mad(x, na.rm = T)\n",
    ")\n",
    "\n",
    "GSE_matrix_df <- GSE_matrix_df[order(GSE_matrix_df$mad_score, decreasing = T), ]\n",
    "GSE_matrix_df <- GSE_matrix_df[!duplicated(GSE_matrix_df$entrez_id), ]\n",
    "rownames(GSE_matrix_df) <- GSE_matrix_df$entrez_id\n",
    "GSE_matrix_df <- GSE_matrix_df[, !grepl(\"entrez_id|mad_score\", colnames(GSE_matrix_df))]\n",
    "GSE_matrix <- as.matrix(GSE_matrix_df)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "head(GSE_matrix)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "dim(GSE_matrix)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## remove genes that have zero counts across all samples"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "GSE_matrix <- GSE_matrix[apply(GSE_matrix, 1, sum)>0, ]\n",
    "message(\"After zero counts gene removal\")\n",
    "message(paste(dim(GSE_matrix)[1], dim(GSE_matrix)[2]))\n",
    "\n",
    "# make zero counts as one so that GSE_matrix geometric mean does not fail\n",
    "GSE_matrix[GSE_matrix==0] <- 1"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## apply DESEQ on the matrix to get rlog transformed counts"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "library(DESeq2)\n",
    "dds <- DESeqDataSetFromMatrix(GSE_matrix, data.frame(samples = rep('a',ncol(GSE_matrix))), design = ~1)\n",
    "dds <- DESeq(dds)\n",
    "GSE_matrix_rlog <- assay(rlog(dds))\n",
    "\n",
    "print(dim(GSE_matrix_rlog))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "GSE_matrix_rlog <- GSE_matrix_rlog[!apply(GSE_matrix_rlog, 1, anyNA), ]\n",
    "dim(GSE_matrix_rlog)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Boxplotting for sanity"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "boxplot(GSE_matrix_rlog)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Get top MAD genes only"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "GSE_WGCNA_matrix <- t(GSE_matrix[order(apply(GSE_matrix_rlog, 1, mad), decreasing = T)[1:5000], ])\n",
    "dim(GSE_WGCNA_matrix)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Apply WGCNA"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "library(WGCNA)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Pick optimal soft-thresholding power beta"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "powers <- c(c(1:10), seq(from = 12, to = 30, by = 2))\n",
    "\n",
    "sft <- pickSoftThreshold(GSE_WGCNA_matrix, powerVector = powers, verbose = 5)\n",
    "sft$fitIndices$plot_param <- -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "sft$fitIndices$plot_param"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "beta <- sft$powerEstimate\n",
    "beta"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Scale-free topology fit index as a function of the soft-thresholding power\n",
    "plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],xlab=\"Soft Threshold (power)\",ylab=\"Scale Free Topology Model Fit, signed R^2\",type=\"n\", main = paste(\"Scale independence\"));\n",
    "text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],labels=powers,cex=cex1,col=\"red\");\n",
    "\n",
    "# Red line corresponds to using an R^2 cut-off\n",
    "abline(h=0.85,col=\"red\")\n",
    "\n",
    "# Mean connectivity as a function of the soft-thresholding power\n",
    "plot(sft$fitIndices[,1], sft$fitIndices[,5],xlab=\"Soft Threshold (power)\",ylab=\"Mean Connectivity\", type=\"n\",main = paste(\"Mean connectivity\"))\n",
    "text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col=\"red\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "adj <- adjacency(GSE_WGCNA_matrix, type = \"signed\", power = beta)\n",
    "\n",
    "# turn adjacency matrix into a topological overlap matrix (TOM) to minimize the effects of noise and spurious associations\n",
    "TOM <- TOMsimilarityFromExpr(GSE_WGCNA_matrix, networkType = \"signed\", TOMType = \"signed\", power = beta)\n",
    "\n",
    "# get dissimilarity matrix from TOM matrix\n",
    "colnames(TOM) <- rownames(TOM)\n",
    "dissTOM <- 1 - TOM\n",
    "\n",
    "# hierarchical clustering of the genes based on the TOM dissimilarity measure\n",
    "geneTree <- hclust(as.dist(dissTOM), method = \"average\")\n",
    "\n",
    "# Set the minimum module size\n",
    "minModuleSize <- 20\n",
    "\n",
    "# cut the tree\n",
    "dynamicMods <- cutreeDynamic(dendro = geneTree, method = \"tree\", minClusterSize = minModuleSize)\n",
    "\n",
    "# the following command gives the module labels and the size of each module. Lable 0 is reserved for unassigned genes\n",
    "dynamicMods <- dynamicMods + 1\n",
    "\n",
    "diag(dissTOM) <- NA\n",
    "dynamicColors <- labels2colors(dynamicMods)\n",
    "print(table(dynamicColors))\n",
    "print(\"Module Lengths\")\n",
    "module_colors <- setdiff(unique(dynamicColors), \"grey\")\n",
    "\n",
    "module_list <- list()\n",
    "for (color in module_colors) {\n",
    "    module <- colnames(GSE_WGCNA_matrix)[which(dynamicColors == color)]\n",
    "\n",
    "    # expand list if slashes exist in entrez ids\n",
    "    module <- unlist(sapply(module, function(x) sapply(strsplit(x, split = \"///\"), trimws),\n",
    "      USE.NAMES = F\n",
    "))\n",
    "\n",
    "module <- module[grep(\"^[0-9]+$\", module)]\n",
    "module <- module[!is.na(module)]\n",
    "module <- module[module != \"\"]\n",
    "module <- module[module != \" \"]\n",
    "if (length(module) > 300) {\n",
    "  next\n",
    "}\n",
    "module_list[[color]] <- paste(module, collapse = \",\")\n",
    "}\n",
    "cat(module_list[[1]][1:50])\n",
    "module_list <- module_list[sapply(module_list, nchar) > 0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "str(module_list)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Upload Rdata to s3"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "aws.s3::s3save_image(\"WGCNA_Examples/WGCNA_RNASEQ.Rdata\", bucket = \"wgcna-geo-datasets\")"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "R",
   "language": "R",
   "name": "ir"
  },
  "language_info": {
   "codemirror_mode": "r",
   "file_extension": ".r",
   "mimetype": "text/x-r-source",
   "name": "R",
   "pygments_lexer": "r",
   "version": "3.5.1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
